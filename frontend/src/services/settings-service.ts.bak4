import { supabase } from '@/integrations/supabase/client';
import { ClubSettings, MemberFeeSettings, FeePayment } from '@/types/settings';
import { camelToSnakeCase } from './utils';

const SETTINGS_TABLE = 'club_settings';
const MEMBER_FEE_SETTINGS_TABLE = 'member_fee_settings';
const FEE_PAYMENTS_TABLE = 'fee_payments';

// Valor padrão para configurações do clube
const DEFAULT_SETTINGS: ClubSettings = {
  name: 'Mouros Moto Hub',
  shortName: 'Mouros MC',
  foundingDate: '2015-01-01',
  logoUrl: '/assets/logo-default.png',
  bannerUrl: '/assets/banner-default.jpg',
  
  primaryColor: '#e11d48', // Mouro Red
  secondaryColor: '#27272a', // Mouro Black
  accentColor: '#f59e0b', // Amber
  textColor: '#27272a',
  
  annualFee: 60.00,
  feeStartDate: '2015-01-01',
  inactivePeriods: [],
  
  address: 'Rua Principal, 123 - Centro, Mouros',
  email: 'info@mourosmotohub.pt',
  phone: '+351 123 456 789',
  
  description: 'Associação motociclística dedicada à paixão pelas duas rodas e ao companheirismo.',
  welcomeMessage: 'Bem-vindo ao Mouros Moto Hub! Junte-se a nós nesta viagem.'
};

// Funções utilitárias para conversão de formato
function snakeToCamelCase(data) {
  if (!data) return {};
  
  return {
    name: data.name,
    shortName: data.short_name,
    foundingDate: data.founding_date,
    logoUrl: data.logo_url,
    bannerUrl: data.banner_url,
    primaryColor: data.primary_color,
    secondaryColor: data.secondary_color,
    accentColor: data.accent_color,
    textColor: data.text_color,
    annualFee: data.annual_fee,
    feeStartDate: data.fee_start_date,
    address: data.address,
    email: data.email,
    phone: data.phone,
    description: data.description,
    welcomeMessage: data.welcome_message,
    inactivePeriods: Array.isArray(data.inactive_periods) 
      ? data.inactive_periods.map(period => ({      startDate: period.start_date || period.startDate || '',
      endDate: period.end_date || period.endDate || '',
      reason: period.reason || ''
        }))
      : [],
    socialMedia: data.social_media
  };
}

/**
 * Serviço para gerenciar configurações do clube
 */
export const settingsService = {
  /**
   * Obtém as configurações atuais do clube
   */
  async getClubSettings() {
    try {
      const { data, error } = await supabase
        .from(SETTINGS_TABLE)
        .select('*')
        .single();
      
      if (error) {
        console.error('Erro ao buscar configurações:', error);
        return DEFAULT_SETTINGS;
      }
      
      if (!data) {
        return DEFAULT_SETTINGS;
      }
      
      // Converter de snake_case para camelCase
      const convertedData = snakeToCamelCase(data);
      
      // Mesclar com valores padrão para garantir que todos os campos estejam presentes
      return { ...DEFAULT_SETTINGS, ...convertedData };
    } catch (error) {
      console.error('Erro ao processar configurações:', error);
      return DEFAULT_SETTINGS;
    }
  },
  
  /**
   * Atualiza as configurações do clube
   */
  async updateClubSettings(settings: any) {
    try {
      // Verificar se já existem configurações
      const { data: existingData } = await supabase
        .from(SETTINGS_TABLE)
        .select('*')
        .single();
      
      // Converter manualmente para o formato esperado pelo Supabase (snake_case)
      const snakeSettings: any = {};
      
      // Mapeamento direto dos campos
      if (settings.name !== undefined) snakeSettings.name = settings.name;
      if (settings.shortName !== undefined) snakeSettings.short_name = settings.shortName;
      if (settings.foundingDate !== undefined) snakeSettings.founding_date = settings.foundingDate;
      if (settings.logoUrl !== undefined) snakeSettings.logo_url = settings.logoUrl;
      if (settings.bannerUrl !== undefined) snakeSettings.banner_url = settings.bannerUrl;
      if (settings.primaryColor !== undefined) snakeSettings.primary_color = settings.primaryColor;
      if (settings.secondaryColor !== undefined) snakeSettings.secondary_color = settings.secondaryColor;
      if (settings.accentColor !== undefined) snakeSettings.accent_color = settings.accentColor;
      if (settings.textColor !== undefined) snakeSettings.text_color = settings.textColor;
      if (settings.annualFee !== undefined) snakeSettings.annual_fee = settings.annualFee;
      if (settings.feeStartDate !== undefined) snakeSettings.fee_start_date = settings.feeStartDate;
      if (settings.address !== undefined) snakeSettings.address = settings.address;
      if (settings.email !== undefined) snakeSettings.email = settings.email;
      if (settings.phone !== undefined) snakeSettings.phone = settings.phone;
      if (settings.description !== undefined) snakeSettings.description = settings.description;
      if (settings.welcomeMessage !== undefined) snakeSettings.welcome_message = settings.welcomeMessage;
      if (settings.socialMedia !== undefined) snakeSettings.social_media = settings.socialMedia;
      
      // Tratamento específico para arrays
      if (settings.inactivePeriods && Array.isArray(settings.inactivePeriods)) {
        snakeSettings.inactive_periods = settings.inactivePeriods.map((p: any) => ({
          start_date: p.startDate,
          end_date: p.endDate,
          reason: p.reason
        }));
      }
      
      if (existingData) {
        // Atualizar configurações existentes
        const { data, error } = await supabase
          .from(SETTINGS_TABLE)
          .update(snakeSettings)
          .eq('id', existingData.id)
          .select()
          .single();
        
        if (error) throw error;
        return snakeToCamelCase(data);
      } else {
        // Criar novas configurações com os valores padrão        
        const { data, error } = await supabase
          .from(SETTINGS_TABLE)
          .insert(snakeSettings)
          .select()
          .single();
          
        if (error) throw error;
        return snakeToCamelCase(data);
      }
    } catch (error) {
      console.error('Erro ao atualizar configurações:', error);
      throw error;
    }
        
        if (error) throw error;
        return snakeToCamelCase(data);
      }
    } catch (error) {
      console.error('Erro ao atualizar configurações:', error);
      throw error;
    }
  },
  
  /**
   * Obtém configurações de cotas de um membro específico
   */
  async getMemberFeeSettings(memberId) {
    try {
      const { data, error } = await supabase
        .from(MEMBER_FEE_SETTINGS_TABLE)
        .select('*')
        .eq('member_id', memberId)
        .single();
      
      if (error) {
        if (error.code === 'PGRST116') { // Código de registro não encontrado
          return null;
        }
        throw error;
      }
      
      if (!data) return null;
      
      // Converter de snake_case para camelCase
      return {
        memberId: data.member_id,
        joinDate: data.join_date,
        exemptPeriods: Array.isArray(data.exempt_periods) 
          ? data.exempt_periods.map(p => {
              // Garantir que p é um objeto, mesmo se vier como JSON
              const period = typeof p === 'string' ? JSON.parse(p) : p;
              return {
                startDate: period.start_date || period.startDate || '',
                endDate: period.end_date || period.endDate || '',
                reason: period.reason || ''
              };
            })
          : []
      };
    } catch (error) {
      console.error(`Erro ao buscar configurações de cota para o membro ${memberId}:`, error);
      throw error;
    }
  },
  
  /**
   * Define ou atualiza as configurações de cotas de um membro
   */
  async setMemberFeeSettings(settings) {
    try {
      // Converter de camelCase para snake_case
      const snakeSettings = {
        member_id: settings.memberId,
        join_date: settings.joinDate,
        exempt_periods: settings.exemptPeriods.map(p => ({
          start_date: p.startDate,
          end_date: p.endDate,
          reason: p.reason
        }))
      };
      
      const existing = await this.getMemberFeeSettings(settings.memberId);
      
      if (existing) {
        // Atualizar configuração existente
        const { data, error } = await supabase
          .from(MEMBER_FEE_SETTINGS_TABLE)
          .update(snakeSettings)
          .eq('member_id', settings.memberId)
          .select()
          .single();
        
        if (error) throw error;
        return this.getMemberFeeSettings(settings.memberId);
      } else {
        // Criar nova configuração
        const { data, error } = await supabase
          .from(MEMBER_FEE_SETTINGS_TABLE)
          .insert(snakeSettings)
          .select()
          .single();
        
        if (error) throw error;
        return this.getMemberFeeSettings(settings.memberId);
      }
    } catch (error) {
      console.error(`Erro ao atualizar configurações de cota para o membro ${settings.memberId}:`, error);
      throw error;
    }
  },
  
  /**
   * Obtém pagamentos de cotas de um membro
   */
  async getMemberFeePayments(memberId) {
    try {
      const { data, error } = await supabase
        .from(FEE_PAYMENTS_TABLE)
        .select('*')
        .eq('member_id', memberId)
        .order('year', { ascending: true });
      
      if (error) throw error;
      
      if (!data || !Array.isArray(data)) return [];
      
      // Converter de snake_case para camelCase
      return data.map(payment => ({
        memberId: payment.member_id,
        year: payment.year,
        paid: true, // Presumimos que se há registro, está pago
        paidDate: payment.payment_date,
        amount: payment.amount,
        receiptNumber: payment.receipt_url || '',
        notes: payment.notes
      }));
    } catch (error) {
      console.error(`Erro ao buscar pagamentos de cotas do membro ${memberId}:`, error);
      throw error;
    }
  },
  
  /**
   * Registra ou atualiza o pagamento de cota de um membro para um ano específico
   */
  async updateFeePayment(payment) {
    try {
      // Converter de camelCase para snake_case
      const snakePayment = {
        member_id: payment.memberId,
        year: payment.year,
        payment_date: payment.paidDate,
        amount: payment.amount,
        payment_method: 'Transferência', // Valor padrão se não fornecido
        notes: payment.notes,
        receipt_url: payment.receiptNumber
      };
      
      // Verificar se já existe um pagamento para este membro/ano
      const { data: existingPayment } = await supabase
        .from(FEE_PAYMENTS_TABLE)
        .select('*')
        .eq('member_id', payment.memberId)
        .eq('year', payment.year)
        .single();
      
      if (existingPayment) {
        // Atualizar pagamento existente
        const { data, error } = await supabase
          .from(FEE_PAYMENTS_TABLE)
          .update(snakePayment)
          .eq('id', existingPayment.id)
          .select()
          .single();
        
        if (error) throw error;
        
        return {
          memberId: data.member_id,
          year: data.year,
          paid: true,
          paidDate: data.payment_date,
          amount: data.amount,
          receiptNumber: data.receipt_url || '',
          notes: data.notes
        };
      } else {
        // Criar novo registro de pagamento
        const { data, error } = await supabase
          .from(FEE_PAYMENTS_TABLE)
          .insert(snakePayment)
          .select()
          .single();
        
        if (error) throw error;
        
        return {
          memberId: data.member_id,
          year: data.year,
          paid: true,
          paidDate: data.payment_date,
          amount: data.amount,
          receiptNumber: data.receipt_url || '',
          notes: data.notes
        };
      }
    } catch (error) {
      console.error(`Erro ao atualizar pagamento de cota do membro ${payment.memberId} para o ano ${payment.year}:`, error);
      throw error;
    }
  },
  
  /**
   * Calcula todos os anos de cotas devidos para um membro
   * Considera data de fundação do clube, períodos inativos e isenções do membro
   */
  async calculateMemberDueYears(memberId) {
    try {
      // Obter configurações do clube
      const clubSettings = await this.getClubSettings();
      
      // Obter configurações de cotas do membro
      const memberSettings = await this.getMemberFeeSettings(memberId);
      
      // Obter pagamentos já realizados
      const payments = await this.getMemberFeePayments(memberId);
      
      // Data de início para cálculo das cotas
      const clubStartDate = new Date(clubSettings.feeStartDate);
      const startYear = clubStartDate.getFullYear();
      
      // Data de ingresso do membro
      let memberJoinDate;
      if (memberSettings?.joinDate) {
        memberJoinDate = new Date(memberSettings.joinDate);
      } else {
        // Buscar informações do membro na tabela de membros
        const { data: memberData } = await supabase
          .from('members')
          .select('join_date')
          .eq('id', memberId)
          .single();
        
        memberJoinDate = memberData?.join_date 
          ? new Date(memberData.join_date) 
          : new Date(); // Fallback para data atual
      }
      
      const memberJoinYear = memberJoinDate.getFullYear();
      
      // Ano atual
      const currentYear = new Date().getFullYear();
      
      // Processar cada ano desde a fundação do clube ou ingresso do membro (o que for mais recente)
      const startingYear = Math.max(startYear, memberJoinYear);
      const dueYears = [];
      
      for (let year = startingYear; year <= currentYear; year++) {
        // Verificar se o clube estava inativo neste ano
        const clubInactive = clubSettings.inactivePeriods.some(period => {
          const periodStart = new Date(period.startDate).getFullYear();
          const periodEnd = new Date(period.endDate).getFullYear();
          return year >= periodStart && year <= periodEnd;
        });
        
        const clubInactivePeriod = clubSettings.inactivePeriods.find(period => {
          const periodStart = new Date(period.startDate).getFullYear();
          const periodEnd = new Date(period.endDate).getFullYear();
          return year >= periodStart && year <= periodEnd;
        });
        
        // Verificar se o membro está isento neste ano
        const memberExempt = memberSettings?.exemptPeriods?.some(period => {
          const periodStart = new Date(period.startDate).getFullYear();
          const periodEnd = new Date(period.endDate).getFullYear();
          return year >= periodStart && year <= periodEnd;
        }) || false;
        
        const exemptPeriod = memberSettings?.exemptPeriods?.find(period => {
          const periodStart = new Date(period.startDate).getFullYear();
          const periodEnd = new Date(period.endDate).getFullYear();
          return year >= periodStart && year <= periodEnd;
        });
        
        // Determinar se o membro deve pagar a cota neste ano
        const shouldPay = !clubInactive && !memberExempt;
        
        // Adicionar à lista de anos
        dueYears.push({
          year,
          shouldPay,
          exempt: memberExempt,
          exemptReason: exemptPeriod?.reason,
          clubInactive,
          clubInactiveReason: clubInactivePeriod?.reason
        });
      }
      
      return dueYears;
    } catch (error) {
      console.error(`Erro ao calcular anos de cotas para o membro ${memberId}:`, error);
      throw error;
    }
  }
};
